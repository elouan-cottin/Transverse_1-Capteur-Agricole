#include <WiFi.h>
#include <PubSubClient.h>
#include <SimpleDHT.h>

#define uS_TO_S_FACTOR 1000000ULL

// =========================
//  WIFI
// =========================
const char* ssid     = "Capteur-Agri";
const char* password = "Capteur-Agri";

// =========================
//  MQTT
// =========================
const char* mqtt_server = "10.42.0.1";
const int   mqtt_port   = 1883;
const char* mqtt_user   = "dashboard";
const char* mqtt_pass   = "dashboard";
const char* SONDE_ID    = "sonde1";

// =========================
//  PINS
// =========================
const int PIN_DHT11 = 4;
const int PIN_LDR   = 34;
const int PIN_MQ135 = 35;
const int PIN_SOIL  = 32;

// =========================
//  SOIL calibration
// =========================
const int SOIL_DRY = 2590;
const int SOIL_WET = 900;

// =========================
//  DAY / NIGHT thresholds
// =========================
const int LUX_JOUR = 1500;
const int LUX_NUIT = 1000;

// =========================
//  TIMINGS
// =========================
const uint32_t SEND_JOUR_MS      = 30UL * 1000UL; // jour: toutes les 30s
const uint32_t SLEEP_NUIT_S      = 1800;          // nuit: 30 min
const uint32_t WIFI_RETRY_MS     = 60UL * 1000UL; // 1 essai/min
const int NIGHT_STREAK_REQUIRED  = 3;

// =========================
WiFiClient espClient;
PubSubClient client(espClient);
SimpleDHT11 dht11(PIN_DHT11);

// Etat réseau
bool netReady = false;

// =========================
// Utils
// =========================
int soilPercentFromRaw(int raw) {
  int pct = map(raw, SOIL_DRY, SOIL_WET, 0, 100);
  return constrain(pct, 0, 100);
}

String buildTopic() {
  return String("eco/sondes/") + SONDE_ID + "/mesures";
}

void wifiOffClean() {
  WiFi.disconnect(true, true);
  WiFi.mode(WIFI_OFF);
  delay(100);
}

// =========================
// Network
// =========================
bool tryWiFiOnce(uint32_t timeoutMs = 12000) {
  if (WiFi.status() == WL_CONNECTED) return true;

  WiFi.persistent(false);
  WiFi.setAutoReconnect(true);
  WiFi.mode(WIFI_STA);

  WiFi.disconnect(true, true);
  delay(200);

  Serial.print("WiFi -> ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < timeoutMs) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("WiFi OK, IP=");
    Serial.println(WiFi.localIP());
    Serial.print("RSSI=");
    Serial.println(WiFi.RSSI());
    return true;
  }

  Serial.println("WiFi KO");
  return false;
}

bool tryMQTTOnce(uint32_t timeoutMs = 8000) {
  client.setServer(mqtt_server, mqtt_port);
  if (client.connected()) return true;

  Serial.print("MQTT...");
  uint32_t t0 = millis();
  while (!client.connected() && millis() - t0 < timeoutMs) {

    if (client.connect(SONDE_ID, mqtt_user, mqtt_pass)) {
      Serial.println(" OK");
      return true;
    }

    Serial.print(" fail state=");
    Serial.println(client.state());
    delay(1000);
  }
  Serial.println(" MQTT KO");
  return false;
}

bool ensureNetwork() {
  bool wifiOK = (WiFi.status() == WL_CONNECTED) ? true : tryWiFiOnce();
  if (!wifiOK) return false;

  bool mqttOK = client.connected() ? true : tryMQTTOnce();
  return mqttOK;
}

// =========================
// Power / Night
// =========================
bool isNightFromLum(int lumRaw) {
  if (lumRaw <= LUX_NUIT) return true;
  if (lumRaw >= LUX_JOUR) return false;
  return false; // zone grise => jour (IMPORTANT)
}

void deepSleepNight() {
  Serial.println("Deep sleep NUIT (30 min)");
  wifiOffClean();
  esp_sleep_enable_timer_wakeup((uint64_t)SLEEP_NUIT_S * uS_TO_S_FACTOR);
  delay(200);
  esp_deep_sleep_start();
}

// =========================
// Publish
// =========================
void publishOnce(const char* modeLabel) {

  byte t = 0, h = 0;
  int dhtErr = dht11.read(&t, &h, NULL);

  int lumRaw  = analogRead(PIN_LDR);
  int soilRaw = analogRead(PIN_SOIL);
  int soilPct = soilPercentFromRaw(soilRaw);

  long mqSum = 0;
  for (int i = 0; i < 20; i++) {
    mqSum += analogRead(PIN_MQ135);
    delay(20);
  }
  int mqRaw = mqSum / 20;

  String payload = "{";
  payload += "\"id\":\"" + String(SONDE_ID) + "\"";
  payload += ",\"mode\":\"" + String(modeLabel) + "\"";

  if (dhtErr == SimpleDHTErrSuccess) {
    payload += ",\"temp\":" + String((int)t);
    payload += ",\"hum_air\":" + String((int)h);
  } else {
    payload += ",\"dht_err\":" + String(dhtErr);
  }

  payload += ",\"lum_raw\":" + String(lumRaw);
  payload += ",\"soil_pct\":" + String(soilPct);
  payload += ",\"mq_raw\":" + String(mqRaw);
  payload += "}";

  Serial.println(payload);

  if (client.connected()) {
    bool ok = client.publish(buildTopic().c_str(), payload.c_str());
    Serial.print("MQTT publish -> ");
    Serial.println(ok ? "OK" : "FAIL");
  } else {
    Serial.println("MQTT not connected -> no publish");
  }
}

// =========================
// Arduino
// =========================
void setup() {
  Serial.begin(115200);
  delay(300);

  Serial.println("\n=== SONDE ESP32 ===");
  Serial.print("ID: ");
  Serial.println(SONDE_ID);
}

void loop() {
  static unsigned long lastWifiTry = 0;
  static unsigned long lastSendDay = 0;
  static int nightStreak = 0;

  client.loop();

  // PRIORITÉ réseau
  if (!netReady) {
    if (millis() - lastWifiTry >= WIFI_RETRY_MS || lastWifiTry == 0) {
      lastWifiTry = millis();
      Serial.println("== Tentative reseau ==");
      netReady = ensureNetwork();
      if (netReady) {
        Serial.println("== RESEAU OK ==");
        lastSendDay = 0;
        nightStreak = 0;
      }
    }
    delay(50);
    return;
  }

  int lum = analogRead(PIN_LDR);
  bool isNight = isNightFromLum(lum);

  if (isNight) {
    publishOnce("night");
    deepSleepNight();
  }

  if (millis() - lastSendDay >= SEND_JOUR_MS || lastSendDay == 0) {
    lastSendDay = millis();

    Serial.print("Lum = ");
    Serial.println(lum);

    if (lum <= LUX_NUIT) nightStreak++;
    else nightStreak = 0;

    publishOnce("day");

    if (nightStreak >= NIGHT_STREAK_REQUIRED) {
      publishOnce("night");
      deepSleepNight();
    }
  }

  delay(50);
}
