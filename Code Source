#include <WiFi.h>
#include <PubSubClient.h>
#include <SimpleDHT.h>

#define uS_TO_S_FACTOR 1000000ULL

// =========================
//  WIFI
// =========================
const char* ssid     = "Capteur-Agri";
const char* password = "Capteur-Agri";

// =========================
//  MQTT
// =========================
const char* mqtt_server = "10.42.0.1";
const int   mqtt_port   = 1883;
const char* SONDE_ID    = "sonde1";

// =========================
//  PINS
// =========================
const int PIN_DHT11 = 4;
const int PIN_LDR   = 34;
const int PIN_MQ135 = 35;
const int PIN_SOIL  = 32;

// =========================
//  SOIL calibration
// =========================
const int SOIL_DRY = 2590;
const int SOIL_WET = 900;

// =========================
//  DAY / NIGHT thresholds
// =========================
const int LUX_JOUR = 1500;
const int LUX_NUIT = 1000;

// =========================
//  TIMINGS
// =========================
const uint32_t SEND_JOUR_MS = 30UL * 1000UL; // jour: envoi toutes les 30s
const uint32_t SLEEP_NUIT_S = 1800;          // nuit: deep sleep 30 min

// Anti-bascule jour->nuit (3 mesures consécutives)
const int NIGHT_STREAK_REQUIRED = 3;

// Backoff si WiFi/MQTT KO (évite de marteler le hotspot)
const uint32_t SLEEP_WIFI_FAIL_S = 120; // 2 min

// =========================
WiFiClient espClient;
PubSubClient client(espClient);
SimpleDHT11 dht11(PIN_DHT11);

// =========================
int soilPercentFromRaw(int raw) {
  int pct = map(raw, SOIL_DRY, SOIL_WET, 0, 100);
  return constrain(pct, 0, 100);
}

String buildTopic() {
  return String("eco/sondes/") + SONDE_ID + "/mesures";
}

// Nettoyage WiFi propre (important pour hotspot Linux)
void wifiOffClean() {
  WiFi.disconnect(true, true);
  WiFi.mode(WIFI_OFF);
  delay(100);
}

// Connexion WiFi robuste
bool connectWiFi(uint32_t timeoutMs = 15000) {
  if (WiFi.status() == WL_CONNECTED) return true;

  WiFi.persistent(false);
  WiFi.setAutoReconnect(true);
  WiFi.mode(WIFI_STA);

  // Nettoyage fort (évite état WiFi bloqué)
  WiFi.disconnect(true, true);
  delay(200);

  Serial.print("WiFi -> ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < timeoutMs) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("WiFi OK, IP = ");
    Serial.println(WiFi.localIP());
    Serial.print("RSSI = ");
    Serial.println(WiFi.RSSI());
    return true;
  }

  Serial.println("WiFi ECHEC");
  return false;
}

// Connexion MQTT robuste
bool connectMQTT(uint32_t timeoutMs = 8000) {
  client.setServer(mqtt_server, mqtt_port);
  if (client.connected()) return true;

  Serial.print("MQTT...");
  uint32_t t0 = millis();
  while (!client.connected() && millis() - t0 < timeoutMs) {
    if (client.connect(SONDE_ID)) {
      Serial.println(" OK");
      return true;
    }
    Serial.print(" fail=");
    Serial.println(client.state());
    delay(1000);
  }
  Serial.println(" MQTT ECHEC");
  return false;
}

void deepSleepSeconds(uint32_t seconds) {
  Serial.print("Deep sleep ");
  Serial.print(seconds);
  Serial.println(" s");
  wifiOffClean();
  esp_sleep_enable_timer_wakeup((uint64_t)seconds * uS_TO_S_FACTOR);
  delay(200);
  esp_deep_sleep_start();
}

void publishOnce(const char* modeLabel) {
  byte t = 0, h = 0;
  int dhtErr = dht11.read(&t, &h, NULL);

  int lumRaw  = analogRead(PIN_LDR);
  int soilRaw = analogRead(PIN_SOIL);
  int soilPct = soilPercentFromRaw(soilRaw);

  long mqSum = 0;
  for (int i = 0; i < 20; i++) {
    mqSum += analogRead(PIN_MQ135);
    delay(20);
  }
  int mqRaw = mqSum / 20;

  String payload = "{";
  payload += "\"id\":\"" + String(SONDE_ID) + "\"";
  payload += ",\"mode\":\"" + String(modeLabel) + "\"";

  if (dhtErr == SimpleDHTErrSuccess) {
    payload += ",\"temp\":" + String((int)t);
    payload += ",\"hum_air\":" + String((int)h);
  } else {
    payload += ",\"dht_err\":" + String(dhtErr);
  }

  payload += ",\"lum_raw\":" + String(lumRaw);
  payload += ",\"soil_pct\":" + String(soilPct);
  payload += ",\"mq_raw\":" + String(mqRaw);
  payload += "}";

  Serial.println(payload);

  if (client.connected()) {
    client.publish(buildTopic().c_str(), payload.c_str());
    Serial.println("MQTT envoyé");
  }
}

// =========================
void setup() {
  Serial.begin(115200);
  delay(300);

  Serial.println("\n=== SONDE ESP32 (fix WiFi + deep sleep nuit) ===");
  Serial.print("ID: ");
  Serial.println(SONDE_ID);

  delay(200);
  int lum0 = analogRead(PIN_LDR);

  bool isNight = (lum0 <= LUX_NUIT);
  bool isDay   = (lum0 >= LUX_JOUR);
  if (!isNight && !isDay) isNight = true; // zone grise -> nuit

  Serial.print("Luminosite start = ");
  Serial.print(lum0);
  Serial.print(" -> ");
  Serial.println(isNight ? "NUIT" : "JOUR");

  bool wifiOK = connectWiFi();
  bool mqttOK = wifiOK && connectMQTT();

  // Si réseau KO -> backoff pour ne pas saturer le hotspot
  if (!mqttOK) {
    Serial.println("Réseau KO -> backoff");
    deepSleepSeconds(SLEEP_WIFI_FAIL_S);
  }

  // ===== NUIT =====
  if (isNight) {
    publishOnce("night");
    deepSleepSeconds(SLEEP_NUIT_S);
  }

  // ===== JOUR =====
  Serial.println("Mode JOUR (envoi toutes les 30 s)");
}

// =========================
void loop() {
  static unsigned long lastSend = 0;
  static int nightStreak = 0;

  client.loop();

  if (millis() - lastSend >= SEND_JOUR_MS) {
    lastSend = millis();

    int lum = analogRead(PIN_LDR);
    Serial.print("Check lum = ");
    Serial.println(lum);

    if (lum <= LUX_NUIT) nightStreak++;
    else nightStreak = 0;

    publishOnce("day");

    // Bascule vers la nuit si confirmé
    if (nightStreak >= NIGHT_STREAK_REQUIRED) {
      Serial.println("Nuit confirmee -> deep sleep");
      publishOnce("night");
      deepSleepSeconds(SLEEP_NUIT_S);
    }
  }

  delay(50);
}
