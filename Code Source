#include <WiFi.h>
#include <PubSubClient.h>
#include <SimpleDHT.h>

#define uS_TO_S_FACTOR 1000000ULL

// =========================
//  WIFI
// =========================
const char* ssid     = "Capteur-Agri";
const char* password = "Capteur-Agri";

// =========================
//  MQTT
// =========================
const char* mqtt_server = "10.42.0.1";
const int   mqtt_port   = 1883;
const char* SONDE_ID    = "sonde1";

// =========================
//  PINS
// =========================
const int PIN_DHT11 = 4;
const int PIN_LDR   = 34;
const int PIN_MQ135 = 35;
const int PIN_SOIL  = 32;

// =========================
//  SOIL calibration
// =========================
const int SOIL_DRY = 2590;
const int SOIL_WET = 900;

// =========================
//  DAY / NIGHT thresholds
// =========================
const int LUX_JOUR = 1500;
const int LUX_NUIT = 1000;

// =========================
//  TIMINGS
// =========================
const uint32_t SEND_JOUR_MS      = 30UL * 1000UL; // jour: envoi toutes les 30s
const uint32_t SLEEP_NUIT_S      = 1800;          // nuit: deep sleep 30 min
const uint32_t WIFI_RETRY_MS     = 60UL * 1000UL; // priorité: 1 essai/min si pas connecté
const int NIGHT_STREAK_REQUIRED  = 3;             // bascule jour->nuit confirmée

// =========================
WiFiClient espClient;
PubSubClient client(espClient);
SimpleDHT11 dht11(PIN_DHT11);

// Etat réseau
bool netReady = false; // WiFi + MQTT OK

// -------------------------
int soilPercentFromRaw(int raw) {
  int pct = map(raw, SOIL_DRY, SOIL_WET, 0, 100);
  return constrain(pct, 0, 100);
}

String buildTopic() {
  return String("eco/sondes/") + SONDE_ID + "/mesures";
}

void wifiOffClean() {
  WiFi.disconnect(true, true);
  WiFi.mode(WIFI_OFF);
  delay(100);
}

// Tentative WiFi "clean"
bool tryWiFiOnce(uint32_t timeoutMs = 12000) {
  if (WiFi.status() == WL_CONNECTED) return true;

  WiFi.persistent(false);
  WiFi.setAutoReconnect(true);
  WiFi.mode(WIFI_STA);

  WiFi.disconnect(true, true);
  delay(200);

  Serial.print("WiFi -> ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < timeoutMs) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("WiFi OK, IP=");
    Serial.println(WiFi.localIP());
    Serial.print("RSSI=");
    Serial.println(WiFi.RSSI());
    return true;
  }

  Serial.println("WiFi KO");
  return false;
}

bool tryMQTTOnce(uint32_t timeoutMs = 8000) {
  client.setServer(mqtt_server, mqtt_port);
  if (client.connected()) return true;

  Serial.print("MQTT...");
  uint32_t t0 = millis();
  while (!client.connected() && millis() - t0 < timeoutMs) {
    if (client.connect(SONDE_ID)) {
      Serial.println(" OK");
      return true;
    }
    Serial.print(" fail=");
    Serial.println(client.state());
    delay(1000);
  }
  Serial.println(" MQTT KO");
  return false;
}

// Essaie de rendre le réseau "OK" (WiFi + MQTT)
// Ne spam pas: on l'appelle au plus 1 fois/min depuis loop()
bool ensureNetwork() {
  bool wifiOK = (WiFi.status() == WL_CONNECTED) ? true : tryWiFiOnce();
  if (!wifiOK) return false;

  bool mqttOK = client.connected() ? true : tryMQTTOnce();
  return mqttOK;
}

void deepSleepNight() {
  Serial.println("Deep sleep NUIT (30 min)");
  wifiOffClean();
  esp_sleep_enable_timer_wakeup((uint64_t)SLEEP_NUIT_S * uS_TO_S_FACTOR);
  delay(200);
  esp_deep_sleep_start();
}

bool isNightFromLum(int lumRaw) {
  bool night = (lumRaw <= LUX_NUIT);
  bool day   = (lumRaw >= LUX_JOUR);
  if (!night && !day) night = true; // zone grise => nuit
  return night;
}

void publishOnce(const char* modeLabel) {
  // Lectures
  byte t = 0, h = 0;
  int dhtErr = dht11.read(&t, &h, NULL);

  int lumRaw  = analogRead(PIN_LDR);
  int soilRaw = analogRead(PIN_SOIL);
  int soilPct = soilPercentFromRaw(soilRaw);

  long mqSum = 0;
  for (int i = 0; i < 20; i++) {
    mqSum += analogRead(PIN_MQ135);
    delay(20);
  }
  int mqRaw = mqSum / 20;

  // JSON
  String payload = "{";
  payload += "\"id\":\"" + String(SONDE_ID) + "\"";
  payload += ",\"mode\":\"" + String(modeLabel) + "\"";

  if (dhtErr == SimpleDHTErrSuccess) {
    payload += ",\"temp\":" + String((int)t);
    payload += ",\"hum_air\":" + String((int)h);
  } else {
    payload += ",\"dht_err\":" + String(dhtErr);
  }

  payload += ",\"lum_raw\":" + String(lumRaw);
  payload += ",\"soil_pct\":" + String(soilPct);
  payload += ",\"mq_raw\":" + String(mqRaw);
  payload += "}";

  Serial.println(payload);

  // Publish uniquement si réseau prêt
  if (client.connected()) {
    client.publish(buildTopic().c_str(), payload.c_str());
    Serial.println("MQTT envoyé");
  }
}

// =========================
void setup() {
  Serial.begin(115200);
  delay(300);

  Serial.println("\n=== SONDE ESP32 (PRIORITE WIFI) ===");
  Serial.print("ID: ");
  Serial.println(SONDE_ID);

  // On ne fait rien d'autre tant que netReady n'est pas vrai.
  // (La loop s'en occupe, 1 essai/min.)
}

// =========================
void loop() {
  static unsigned long lastWifiTry = 0;
  static unsigned long lastSendDay = 0;
  static int nightStreak = 0;

  // Toujours faire tourner MQTT si connecté
  client.loop();

  // 1) PRIORITE: tenter réseau au max 1 fois/min tant que pas prêt
  if (!netReady) {
    if (millis() - lastWifiTry >= WIFI_RETRY_MS || lastWifiTry == 0) {
      lastWifiTry = millis();
      Serial.println("== Tentative reseau (max 1/min) ==");
      netReady = ensureNetwork();
      if (netReady) {
        Serial.println("== RESEAU OK -> activation des mesures ==");
        // Reset timing d’envoi
        lastSendDay = 0;
        nightStreak = 0;
      }
    }
    delay(50);
    return; // IMPORTANT: on ne fait rien d'autre tant que netReady=false
  }

  // 2) Réseau OK -> on fait le job normal
  int lum = analogRead(PIN_LDR);
  bool isNight = isNightFromLum(lum);

  // Nuit -> 1 envoi puis deep sleep 30 min
  if (isNight) {
    publishOnce("night");
    deepSleepNight(); // ne revient pas
  }

  // Jour -> envoi toutes les 30s
  if (millis() - lastSendDay >= SEND_JOUR_MS || lastSendDay == 0) {
    lastSendDay = millis();

    Serial.print("Check lum = ");
    Serial.println(lum);

    // Détection nuit confirmée (si tu caches le LDR)
    if (lum <= LUX_NUIT) nightStreak++;
    else nightStreak = 0;

    publishOnce("day");

    // Si nuit confirmée plusieurs fois -> passage en nuit
    if (nightStreak >= NIGHT_STREAK_REQUIRED) {
      publishOnce("night");
      deepSleepNight();
    }
  }

  delay(50);
}
